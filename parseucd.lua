-- generate useful data from Unicode Character Database.
-- you should have these files in UCD folder in current path:
--   - UCD\DerivedCoreProperties.txt
--   - UCD\EastAsianWidth.txt
--
--  files can be downloaded at: https://unicode.org/Public/UCD/latest/ucd/


local function parse_EastAsianWidth()
    local wide, ambi = {}, {}

    for line in io.lines() do
        local trimed = line:gsub("%s*%#.*$", "")
        if trimed ~= "" then
            local first, last, mark
            first, mark = trimed:match "^(%x+)%s*%;%s*(%w+)$"
            if first then
                last = first
            else
                first, last, mark = trimed:match "^(%x+)%.%.(%x+)%s*%;%s*(%w+)$"
                assert(first, trimed)
            end

            first = tonumber(first, 16)
            last = tonumber(last, 16)

            if mark == 'W' or mark == 'F' then
                for i = first, last do
                    wide[#wide + 1] = i
                end
            elseif mark == 'A' then
                for i = first, last do
                    ambi[#ambi + 1] = i
                end
            end
        end
    end

    return wide, ambi
end

--- @param f string|table|fun(cp: integer):boolean
local function parse_PropList(f)
    local ranges = {}
    local lookup = {}

    local arg = f
    if type(f) == 'table' then
        f = function(cp) return arg[cp] end
    elseif type(f) == 'string' then
        f = function(cp) return arg == cp end
    end

    for line in io.lines() do
        local trimed = line:gsub("%s*%#.*$", "")
        if trimed ~= "" then
            local first, last, mark
            first, mark = trimed:match "^(%x+)%s*%;%s*([%w%s_;]+)%s*$"
            if first then
                last = first
            else
                first, last, mark = trimed:match "^(%x+)%.%.(%x+)%s*%;%s*([%w%s_;]+)%s*$"
                assert(first, trimed)
            end

            first = tonumber(first, 16)
            last = tonumber(last, 16)

            if f(mark) then
                for i = first, last do
                    if not lookup[i] then
                        lookup[i] = true
                        ranges[#ranges + 1] = i
                    end
                end
            end
        end
    end

    table.sort(ranges)
    return ranges, lookup
end

local function get_ranges(list, func)
    local first, last, step, offset
    local ranges = {}
    for i = 1, #list do
        local v_cp, v_offset
        local v = list[i]
        local res = not func or func(v)
        if type(v) == 'number' then
            v_cp, v_offset = v, nil
        elseif v.cp then
            v_cp, v_offset = v.cp, v.offset
        end
        if res then
            if first and
                (not offset or offset == v_offset) and
                (not step or step == v_cp - last) then
                step = v_cp - last
                last = v_cp
            else
                if first then
                    local r = { first = first, last = last, step = step, offset = offset }
                    ranges[#ranges + 1] = r
                end
                first, last, step = v_cp, v_cp, nil
                offset = v_offset
            end
        end
    end
    if first then
        local r = { first = first, last = last, step = step, offset = offset }
        ranges[#ranges + 1] = r
    end
    return ranges
end

local function write_ranges(name, ranges)
    io.write("static struct range_table " .. name .. "_table[] = {\n")
    for _, r in ipairs(ranges) do
        io.write(("    { 0x%X, 0x%X, %d },\n"):format(r.first, r.last, r.step or 1))
    end
    io.write "};\n\n"
end

io.output "unidata.h"

io.write [[
/*
 * unidata.h - generated by parseucd.lua
 */
#ifndef unidata_h
#define unidata_h

#ifndef utfint
# define utfint utfint
typedef unsigned int utfint;
#endif

typedef struct range_table {
    utfint first;
    utfint last;
    int step;
} range_table;

]]

do
    local function ranges(name, f)
        local r = get_ranges((parse_PropList(f)))
        write_ranges(name, r)
    end

    io.input "UCD/DerivedCoreProperties.txt"
    ranges("zerowidth", {
        Default_Ignorable_Code_Point = true,
        Grapheme_Extend = true,
    })
end

do
    io.input "UCD/EastAsianWidth.txt"
    local wide, ambi = parse_EastAsianWidth()
    write_ranges("doublewidth", get_ranges(wide))
    write_ranges("ambiwidth", get_ranges(ambi))
end

io.write "#endif /* unidata_h */\n"
