# Musubi 的开发笔记

找一个地方写一下为什么我会开发[这个库](https://github.com/starwing/musubi)。

## 初始动机和选型

实现或者找到一个好看好用的诊断信息显示库一直是我的一个想法，毕竟 Lua 的堆栈信息显示基本上可以用简陋来形容了。正好最近我在考虑实现一个基于代数效应的语言，类似 Rust 语法，转换成 C。于是可以调研一下当前有什么好用的诊断库了。我打算先用 Lua 做一个编译器原型，毕竟 Rust 要求一上来就想得很清楚，而 Go 有点笨重。我是很喜欢纯 C 的，但是上来就用纯 C 做原型有点太夸张了。不过只要有一个 Rust 的实现，为它做一个 Lua 绑定是很容易的事情。

我最开始被 [ariadne](https://github.com/zesterer/ariadne) 吸引了，它的效果看上去非常好，不过我当时非常想要一个“宽度限制”的功能——这是我过去想实现一个好用的诊断库的一个主要原因：当代码长度太长的时候（通常是针对一些生成代码），我希望诊断库能在有限的长度下有效抽取出最值得关注的片段来显示。在搜索中我找到了 [codesnake](https://github.com/01mf02/codesnake) 库，它几乎一样好，而且据说是 ariadne 的某种重写，他也评论了其他的几个库。他描述自己写一个的主要原因是 ariadne 曾经破坏了 semver 让他的代码挂了。我也尝试了 codesnake 但是上来就失败了——它不支持重叠的标签。

我那个时候还不知道 [annotate-snippets](https://github.com/rust-lang/annotate-snippets-rs)，这实在的有点蠢——毕竟最开始吸引我在 Rust 中寻找合适的库就是因为 rustc 的诊断信息很漂亮，且有一个“140 字符长度的软限制”。但其实我是在实现 musubi 之后才注意到 annotate-snippets 的。这是 rustc 的钦定的诊断库。一开始我觉得 annotete-snippets 的接口有点晦涩，但习惯以后其实还好。而且 annotate-snippets 的“diff模式”看起来很有用，它也支持在 help/note 后面再跟着其他的元素，相对比较灵活。它唯一一个“问题”可能是在标签后面直接跟着消息文本会显得有点长。但其实还好。不过它的接口的确没什么办法简单实现，基本是一个完全依赖 Rust 表现能力的库，没办法在 C 里实现出比较灵活好看的接口。

反正，因为 ariadne 不支持限宽，而 codesnake 不支持重叠标签，网上的评论看起来对 [miette](https://github.com/zkat/miette) 都有点意见（比如基于 derive 啊，没有 ariadne 灵活啊），再加上 ariadne 那个巨大的 render 函数实在是看起来不是很靠谱（[它自己的注释](https://github.com/zesterer/ariadne/blob/4b3807ca8872190aec080e1825b6852b7d2b68ba/src/write.rs#L9)都提到这玩意很难看懂很难改），所以我开始决定自己实现一个 ariadne clone，一方面学习这么复杂的诊断输出是如何计算的，一方面 port 到 C 能让我实现一个 Lua 绑定。顺便还能练习怎么在 Rust 中绑定纯 C 代码（据说很简单，我想试试看），以及练习下 LLM vibe coding （事实证明，这是个目前不成熟的领域……）我就开始了。

## Lua 原型开发

最开始我想得很简单，我直接对 Copilot 说“我有一个 Rust 项目，请将它一比一翻译到 Lua”，我想先拿到一个对应的 Lua 代码，再慢慢修改。事实证明这就是个灾难。反正我用完了 Copilot Pro 所有的 tokens 配额，生成的代码依然没办法使用。我发现它实际上忽略了很多逻辑，然后用各种得过且过的方式来让单测勉强能过。“这样不行”，我这么想，反正两个星期以后，我删掉了 LLM 生成的所有代码，我决定自己来。

将 ariadne 翻译到 Lua 其实还蛮顺利的，我基本上三天就[做完了这个工作](https://github.com/starwing/musubi/blob/4b90e6b89efea36e64035b40ab0a3fd181efca44/ariadne.lua)，中间还做了重构，从 OOP 风格转换成 C 风格以方便后续的 C 移植。实际上我发现 LLM 最大优势其实是审核我的代码，它能找到一些低级错误，但也就如此了，实际上他说代码质量很好的情况下，依然需要调式解决一些他没找到的问题。反正最终我将 ariadne 翻译到了 Lua。成功跑过了大部分 airadne 自带的单测——虽然 ariadne 自己的单测其实也不多。

然后我在这个基础上开始优化代码，首先干掉所有的 lambda，用外部函数代替。将其拆分成 C 能处理的样子。然后一些复杂的地方——比如[ `write_margin`](https://github.com/zesterer/ariadne/blob/4b3807ca8872190aec080e1825b6852b7d2b68ba/src/write.rs#L337)，被拆解成多个函数（[`render_lineno`](https://github.com/starwing/musubi/blob/4b90e6b89efea36e64035b40ab0a3fd181efca44/ariadne.lua#L1392)，[`render_margin`](https://github.com/starwing/musubi/blob/4b90e6b89efea36e64035b40ab0a3fd181efca44/ariadne.lua#L1189) 等）。这时我发现了一些 ariadne 自己的 bug，以及实现上不靠谱的地方。最明显的是那个巨大的 `write_margin` 使用了一个双重循环。这里要说一下 ariadne 渲染出来的东西的一些命名，以下面的输出来算：

```test
[3] Error: Incompatible types
   ,-[ sample.tao:1:12 ]
   |
 1 | ,-----> def five = match () in {
   | |                  ^
   | | ,----------------'
 2 | | |         () => 5,
   | | |               |
   | | |               `-- This is of type Nat
 3 | | |         () => "5",
   | | |               ^|^
   | | |                `--- This is of type Str
 4 | | |---> }
   | | |     ^
   | | `--------- This values are outputs of this match expression
   | |       |
   | `-------^--- The definition has a problem
   |
 6 |     ,-> def six =
   :     :
 8 |     |->     + 1
   |     |
   |     `------------- Usage of definition here
   |
   | Note: Outputs of match expressions must coerce to the same type
---'
```

最上面的 `[3] Error: ...` 叫 header，最下面的 note 到结尾叫 footer，中间的部分根据代码文件的不同被分组成不同的 group。而 margin 就是每行代码左边那些竖线和横着的箭头所在的位置。这个位置你也可以看到，是“每个多行标签有两个字符宽度”来绘制的，`write_margin` 就是干这个事的。

`write_margin` 的外重循环会从 0 到 len+1 去计算当前的两个字符（`compact`模式下只有一个字符）应该显示的信息，而内重会再次从0循环到当前位置来判断比如“当前这个块是不是横线（hbar）啊，竖线（vbar）啊，箭头（ptr）啊”这些信息。我发现其实没有必要每输出两个字符都要从0到当前位置去遍历找这些元素。实际上对边界来说，只要前面有 hbar 或者 ptr，那就意味着后面的基本上不用看了，肯定一直都是有这些元素的。所以这两个值只要在循环的时候一直保持就好了，而转角（corner，上面示例里左边的`,` 和 ` `` `字符）和竖线就需要每次都判断了。由此，一个双重循环被优化成了单重循环+条件判断，大大简化的代码。另外，ptr 的头（`->`）只可能出现在最后，于是也不需要循环 len + 1次了，而是只循环 len 次，出来以后再判断要不要追加一个箭头、横线或者空格。代码更简单了。

这个对原始代码的优化给了我信心，后续的代码重构一直都很顺利，就这样一边优化代码一边测试很快最初的版本就搞定了。然后我在 LLM 的帮助下实现了限宽功能。基本上我列出需求，他列方案，然后我选一个看上去靠谱的然后自己写代码，最后他审核。我发现用这种方式使用 LLM 其实是最好的。然后我让他写单测，但是不要管结果，我自己执行单测看（一定会失败的）结果是否合理，如果合理我就直接粘贴结果到单测里。就这样 Lua 的代码就完成了。修复了很多显示问题，删掉了一些跑不到的逻辑，并做了覆盖，将一些 ariadne 自己都没覆盖的分支用单测覆盖了。到了这一步，LLM 也认为可以考虑移植到 C 了。于是我就开始了。

## C 代码实现

C 的移植很快，其实这种工作用 LLM 应该也能做得好，但是反正我是被搞怕了。经过了三天，C 移植就做完了。我加入了 Lua 绑定，跑过了之前所有的测试样例。相对 Lua 代码，其实最麻烦的是 Unicode 处理——毕竟 C 里可没有 [luautf8](https://github.com/starwing/luautf8) ——好在这个库也是我写的。我将我需要的功能裁剪到了 C 侧。并针对性地做了优化——一个重要的优化是加入了宽度缓存，这有效降低了在 C 里”反复计算代码宽度”需要的实现，直接在宽度缓存里面二分搜索就好了。而且因为有宽度缓存，我可以在这个基础上实现 Lua 都没有的 [UAX#29](https://www.unicode.org/reports/tr29/) 算法（只实现了我需要的部分，比如 Emoji 和国家标记，韩文这些我没管）。而且令人意外的是这修复了 ariadne 一个我都没注意到的 bug—— ariadne 的 Tab stop 是用 col 计算的！而 col 不一定是 1 宽度的，实际上是需要用“从开始到现在的宽度”来计算，而不是 col。这导致了如果一行代码有两个 tab，那么第二个 tab 的计算是错误的。

反正，在确认代码基本上没什么大问题以后（反正覆盖率到 100% 了），我发布了 musubi 的 0.1.0 版本。这个版本的 Rust 绑定基本上是 LLM 写的，但是问题不大，反正核心 C 代码是我写的就行了……是吗？

事实上用 LLM 写代码真的完全不让人放心……反正绑定的质量很差——甚至它直接丢了一个类没绑定……于是我不得不发布了 0.2.0 版本，重新 review 了所有代码，修了一些绑定的问题，加了 LLM 忘掉的 ColorGenerator 绑定和一些他忘掉的文档。最后我加了 Github Action，保证 Lua 绑定能在所有 Lua 版本上跑（这花掉了我一点时间）。

## 新的改进（0.3.0 和 0.4.0 版本）

但是显然还不能放松。我在发布以后自己玩了玩，ariadne 风格的诊断的确很漂亮，但是线条的交叉太多了……反正这个时候我发现了 annotete-snippets 库，它基本上没啥线条交叉（不过我怀疑它能不能支持复杂的多覆盖标签就是了……）。反正，一个解决线条交叉的方法是“先画最右边的标签，然后画左边的，比如说，这是 annotate-snippets 的输出结果：
```text
error: expected type, found `22`
   ╭▸ examples/footer.rs:29:25
   │
26 │                 annotations: vec![SourceAnnotation {
   │                 ┬──────────  ┬──  ──────────────── while parsing this struct
   │                 │            │
   │                 │            This type
   │                 This is the key
   ‡
29 │                 range: <22, 25>,
   ╰╴                        ━━ expected struct `annotate_snippets::snippet::Slice`, found reference
```

而这是 ariadne 的：
```test
Error: expected type, found `22`
   ╭─[ examples/footer.rs:1:27 ]
   │
 1 │                 annotations: vec![SourceAnnotation {
   │                 ─────┬─────  ─┬─  ────────┬───────
   │                      ╰────────────────────────────── This is the key
   │                               │           │
   │                               ╰───────────────────── This type
   │                                           │
   │                                           ╰───────── while parsing this struct
   │
   │
 4 │                 range: <22, 25>,
   │                         ─┬
   │                          ╰── expected struct `annotate_snippets::snippet::Slice`, found reference
───╯
```

可以看到，线条交叉的直接原因就是顺序问题。于是我修复了这个问题——只需要仔细调教标签的顺序就可以了。顺便我改进了 margin 标签的选择问题——我喜欢 ariadne 的一个主要原因是它可以选择一个标签，将它的箭头放在前面的 margin 列里面，以简化标签线条。这次我仔细选择了最合适的标签，以至于[这么复杂的标签](https://github.com/starwing/musubi/blob/be3c499b5440b329b7b3071c980b7a99578a446d/tests/test.lua#L1041)在 `compact` 下的观感都好很多：
```text
Error: natural label order
   ,-[ <unknown>:1:1 ]
 1 |  ,-->first line
   |,-|---'
   ||,|---'
 2 ||||-->second line
   ||||       ^|^|^|^
   ||||       |||||`|-- last inline
   ||||       |||`|-|-- middle inline
   ||||       |`|-|-|-- first inline
   |||`-------|-|-|-|-- margin
   ||`--------|-^-|-|-- first outer
   |`---------|---|-^-- last outer
   |   ,------'   |
   |   |,---------'
 3 |   ||>third line
   |   |`--|---------- first next
   |   `---^---------- second next
```

为了更像 annotate-snippets 那种能省空间的布局，我还加了“禁用标签消息对齐”的选项。然后我就发了 0.3.0 版本。

我本来以为到这基本上就结束了，我可以安心回去写我的代数效应的生成器了，结果随便用用就发现了一个大问题：我通过 `mu_Source` 这个结构存储源代码，但它的生命周期是绑定在 `mu_Report` 上的！这意味着如果我要对一个源代码多次显示标签，我就不得不一次又一次地初始化这些源代码，计算它们的行号位置！这太糟糕了，我决定学习 ariadne，引入 `mu_Cache` 结构（之前我将其融合到 `mu_Report` 了，事实证明这是个坏想法）。`mu_Cache` 和 `mu_Report` 一样支持自定义的内存管理，并内部维护 `mu_Source` 的生命周期。并且 `mu_Source` 因为本身就内嵌了一个 `mu_Cache`，所以可以直接传给 `mu_render` 使用。很舒适啊。但 Rust 绑定就倒了大霉了。这玩意基本是 C 的花活，可怎么绑定啊……反正 LLM 基本上抓瞎了。我只能自己上了，花了一个晚上的时间，尝试了各种方法，最终通过“将 Rust 对象存储到 C 分配的内存上”的办法解决了最主要的生命周期问题，加上各种接口的权衡实现。我就发布了 0.4.0 版本。现在这个版本用起来相对就比较舒适了。

## 新增功能 (0.5.0 版本)

这就结束了吗……？并没有……一个惊天噩耗……在我哼哧哼哧更新代码的时候，我特么的没注意到 4 个月都没更新的 ariadne 他特么地爆发式更新了！我都惊了，我都写完了你才更新？而且它修掉了我之前找到的一些问题（比如 margin 的 hbar 的更新问题），还加上了最小化交叉的功能……行吧……但是我最想要的限宽他并没有实现，并且有些 bug 它还是没修——比如 tab 的计算问题。反正他还做了很多修改，有些修改我觉得很好——比如交叉的时候优先显示竖线而不是横线。这确实清晰多了。但有些修改我就不太喜欢——比如将 ascii 模式下的下划线从  “`^^^`” 改成了 “`---`”。这感觉就没这味了。反正，我加上了 ariadne 更新的一些我喜欢的特性，包括：

- `line_margin` 标记，现在“当前行是代码行”的左边缘标记可以自定义了。
- 左、中、右的 `underbar`，我还加了一个“零宽度”的 `underbar`，这样如果一个标签没有宽度，就可以显示一个箭头一样的下划线表明这一点。
- 跨文件的 `order` 选项。行，听起来合理就是。
- `context_lines` 额外显示上下文长度。也不是不行吧反正，这功能听着也挺有用的。

反正，随着更新功能，我也大幅简化了之前 `mu_Group` 的创建过程。代码更好看了~ 顺便将“可以额外指定位置”这个属性干掉了——反正也用不着。毕竟你随便指定一个连标签都没有的位置感觉怪怪的……但为了用户能指定“这块代码的标记你给我用这个标签的位置显示”的功能，我加了 `primary` 的功能，现在可以指定一个标签是主标签，它的位置会显示在当前代码组的最开头（就是上面示例里面中括号括起来的位置）。反正逻辑更清晰了，代码也更简单了。很好很好。现在 C 代码基本上都由长度在 40 行以内的函数（少数函数有 50 多行，实在是优化不动了……）组成，代码实现清爽干净，加入新功能变得容易很多。

最终，这么简单的一个功能我搞了一个月是我没想到的。如果一开始就不用 LLM 估计还能快点……有研究说明 LLM 会降低程序员的效率，这下我真信了……但 LLM 还是有好处的，一些你想不明白或者不想去想的点可以直接问，让他给思路。让他当赛博小黄鸭。写完了代码让他评审。再加上 Copilot 的代码提示功能的确还蛮好用的。所以其实还是比较有优势。怎么说呢，以“开发效率下降”换取“程序员敢去实现之前没信心能做的功能”，我感觉还是赚的。

所以这就是这个月的开发记录了。musubi 的开发还是蛮有意思的。将 ariadne 那又长又复杂的面条代码慢慢展开，变成 C 代码的过程很好玩。能用自己的库生成漂亮的诊断信息也很有成就感。我可以回去继续研究代数效应了。

## 后续计划

musubi 现在已经是一个功能完整、性能优良的诊断库了。接下来的工作重点会转向：

1. 在我的代数效应编译器中实际使用，积累更多实战经验
2. 继续跟进 ariadne 的更新，吸收有价值的改进
3. 可能考虑实现 annotate-snippets 的 diff 模式
4. 完善文档和使用案例

如果你正在寻找一个轻量、高性能、支持限宽的诊断库，欢迎尝试 [musubi](https://github.com/starwing/musubi)！
